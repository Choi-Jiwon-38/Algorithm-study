# 1주 차 알고리즘 풀이
### 큐 2
python의 deque를 사용하면 매우 쉽게 풀 수 있는 문제 

그러나, deque를 사용하는 건 너무 식상하기도 하고, 이미 deque로 문제를 몇 번 풀어보았기 때문에 다른 방법으로 해결할 수 없을지 생각해 보았다.  

근본적으로, 리스트를 사용할 때 시간복잡도가 높아지는 주요인은 선입선출 과정에서 0번 인덱스에 해당하는 요소를 제거할 때 뒤에 있는 요소들(1, 2, 3...)을 전부 앞으로 한 칸씩 당겨오면서 O(n)의 시간복잡도가 생기는 것이 문제이다.  

이를 제외하고는 문제에서 주어진 연산 내에서 O(1)로 전부 해결 가능하다고 보았고, pop연산 부분만 손보면 괜찮을 것 같다는 결론을 내렸다.  

결국 queue에서 입력한 순서대로 pop을 할 때마다 출력하는 것이기에, 실제로 요소를 삭제하지 않고 요소가 어디까지 출력됐는지 확인할 수 있는 포인터를 하나 추가하면 실제로 요소를 삭제하지 않았기 때문에 O(n)의 연산이 필요하지 않고 pop 연산을 간접적으로 구현할 수 있다고 생각하였다.  

단, 해당 방법에서는 실제로 queue 내에 값이 그대로 남아있기 때문에 메모리를 다소 비효율적으로 사용한다는 단점이 있을 것으로 보인다.  

아니면 queueNum이 10,000에 도달할 때마다 한 번씩 슬라이싱해서 시간복잡도와 메모리를 어느 정도 절충하는 방법도 있을 것 같다. O(n)이긴 하지만 O(n/10,000) 느낌으로 사용할 수 있지 않을까.... 싶다.